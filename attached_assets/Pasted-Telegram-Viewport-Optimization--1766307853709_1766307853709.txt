Telegram Viewport Optimization
Что это даёт
Преимущество	Описание
Идеальное отображение	На всех устройствах, включая iPhone с Dynamic Island
Нет обрезанного контента	Кнопки не скрыты за системными элементами
Haptic feedback	Вибрация при нажатии как в нативных приложениях
Native feel	Ощущение что это нативное приложение
Бизнес-ценность: Пользователь не видит багов = доверяет = покупает.

Проблема без этого: Контент скрыт за "чёлкой" iPhone, кнопки под системной клавиатурой.

Как это работает
Telegram сообщает размеры viewport и safe area
        ↓
React hook слушает изменения
        ↓
CSS custom properties обновляются
        ↓
UI адаптируется автоматически
Реализация
Файл: client/src/hooks/useTelegramViewport.ts

import { useState, useEffect } from 'react';
interface ViewportState {
  height: number;           // Текущая высота viewport
  stableHeight: number;     // Стабильная высота (без клавиатуры)
  isExpanded: boolean;      // Развёрнуто ли на весь экран
  safeArea: {
    top: number;            // Отступ сверху (чёлка, Dynamic Island)
    bottom: number;         // Отступ снизу (home indicator)
    left: number;
    right: number;
  };
}
export function useTelegramViewport(): ViewportState {
  const [viewport, setViewport] = useState<ViewportState>({
    height: window.innerHeight,
    stableHeight: window.innerHeight,
    isExpanded: false,
    safeArea: { top: 0, bottom: 0, left: 0, right: 0 },
  });
  
  useEffect(() => {
    const WebApp = window.Telegram?.WebApp;
    if (!WebApp) {
      console.log('[Viewport] Not in Telegram, using defaults');
      return;
    }
    
    const updateViewport = () => {
      const newViewport = {
        height: WebApp.viewportHeight || window.innerHeight,
        stableHeight: WebApp.viewportStableHeight || window.innerHeight,
        isExpanded: WebApp.isExpanded || false,
        safeArea: {
          top: WebApp.safeAreaInset?.top || 0,
          bottom: WebApp.safeAreaInset?.bottom || 0,
          left: WebApp.safeAreaInset?.left || 0,
          right: WebApp.safeAreaInset?.right || 0,
        },
      };
      
      setViewport(newViewport);
      
      // Обновляем CSS custom properties
      document.documentElement.style.setProperty(
        '--tg-viewport-height', 
        `${newViewport.height}px`
      );
      document.documentElement.style.setProperty(
        '--tg-viewport-stable-height', 
        `${newViewport.stableHeight}px`
      );
      document.documentElement.style.setProperty(
        '--tg-safe-top', 
        `${newViewport.safeArea.top}px`
      );
      document.documentElement.style.setProperty(
        '--tg-safe-bottom', 
        `${newViewport.safeArea.bottom}px`
      );
    };
    
    // Начальное обновление
    updateViewport();
    
    // Подписываемся на изменения
    WebApp.onEvent('viewportChanged', updateViewport);
    
    // Разворачиваем на весь экран
    WebApp.expand();
    
    return () => {
      WebApp.offEvent('viewportChanged', updateViewport);
    };
  }, []);
  
  return viewport;
}
// Использование в CSS:
// 
// .container {
//   height: var(--tg-viewport-height, 100vh);
//   padding-top: var(--tg-safe-top, 0);
//   padding-bottom: var(--tg-safe-bottom, 0);
// }
Файл: client/src/lib/haptics.ts

// Типы тактильной обратной связи
type HapticType = 
  | 'light'          // Лёгкий тап
  | 'medium'         // Обычное нажатие
  | 'heavy'          // Сильное нажатие
  | 'success'        // Успех (зелёная галочка)
  | 'warning'        // Предупреждение
  | 'error'          // Ошибка
  | 'selection';     // Изменение выбора
export function haptic(type: HapticType): void {
  const WebApp = window.Telegram?.WebApp;
  if (!WebApp?.HapticFeedback) return;
  
  try {
    switch (type) {
      case 'light':
      case 'medium':
      case 'heavy':
        WebApp.HapticFeedback.impactOccurred(type);
        break;
      case 'success':
      case 'warning':
      case 'error':
        WebApp.HapticFeedback.notificationOccurred(type);
        break;
      case 'selection':
        WebApp.HapticFeedback.selectionChanged();
        break;
    }
  } catch (error) {
    // Не поддерживается — игнорируем
  }
}
// React hook
export function useHaptic() {
  return {
    light: () => haptic('light'),
    medium: () => haptic('medium'),
    heavy: () => haptic('heavy'),
    success: () => haptic('success'),
    warning: () => haptic('warning'),
    error: () => haptic('error'),
    selection: () => haptic('selection'),
  };
}
// Пример использования:
//
// function LikeButton() {
//   const haptic = useHaptic();
//   
//   return (
//     <Button onClick={() => {
//       haptic.light();  // Вибрация при клике
//       // ...
//     }}>
//       Like
//     </Button>
//   );
// }